# Converted Events

In general, most of the fields that exists on Teravoz's events could be converted from TaskRouter events. The main differences are on **number** fields when they're related to the agent. As in Twilio Flex the agents doesn't have a real peer number, the information present on this number fact is, actually, the `contact_uri` present on the Worker attributes. So,for an agent named `foo` is using flex, the number of the agent provided in the events will be equal to `client:foo`, and not a real peer number. 

Also, when the `queue` attribute is converted, it is converted to the TaskQueue SID, that also is not a phone number.

By the way, here is the list of the Task Router's events and their representation as teravoz events:

## Task events
* task.created -> **call.new**
* task.canceled -> **call.queue-abandon**
* task.wrapup -> **call.finished** AND **actor.left**

## Task Queue Events
* task-queue.entered -> **call.waiting**

## Reservation Events
* reservation.accepted -> **actor.entered** AND **call.ongoing**
* reservation.rejected -> **actor.noanswer**
* reservation.created -> **actor.ringing**

## Worker Events
*  worker.activity.update -> varies considering the WorkerActivityName:
* * If the WorkerActivityName is equal to `available` and he was not already available on the queue, then an **actor.logged-in** event is produced
* * If the WorkerActivityName is equal to `unavailable` or `offline`, while the agent was already not in these two status, then an **actor.logged-out** is produced
* * If the WorkerActivityName is equal to `break`, and the user was not already in the `break` status, then an **actor.paused** is produced
* * At least, if the WorkerActivityName is equal to available and the agent was in a break, then an **actor.unpaused** is produced.

# Dialer events

The Dialer's events are different from the TaskRouter's events. The Dialer's events aren't a default from Twilio, since the dialer itself is a custom implementation made by Teravoz. Therefore, these events are triggered manually in the Dialer's code by sending a POST to the `/dialer` endpoint.

By default, these dialer events names are defined by the name that it represents in Teravoz's events with the prefix `custom.`. So, the conversion of the events are simple:

* custom.dialer.attempt -> **dialer.attempt**
* custom.dialer.success -> **dialer.success**
* custom.dialer.failure -> **dialer.failure**
* custom.dialer.expired -> **dialer.expired**
* custom.dialer.exceeded -> **dialer.exceeded**


# Converted Inputs
The user inputs events are generated by custom Twilio's function and are not received by POSTing the `/webhook` endpoint. Instead, the input data will be received on the `/input` route, and will also convert the received input to Teravoz's events. As these events aren't officialy emitted by task-router, they've fully customizable names that can be changed. For now, only the NPS input gathered by user is converted:

* custom.nps-provided -> **call.data-provided**, with the fields `data` and `nps` filled with the user evaluation of the call.


# Points to Review

* ~~When the Task enters in the wrapup state (task.wrapup event), two Teravoz's events are fired: `call.finished` AND `agent.left`. However, maybe the actor.left event should be fired when the task finishes (task.completed event), because only on the end of the wrapup status the agent will be available again.~~

>The point above doesn't seems to make sense now, but I'll leave it here with a stroke just in case.

* When a `actor.noanswer` is produced, the `ringtime` is equals to the task age on Twilio's Task Router, not the time that was ringing to the extension that have rejected or not answered the call.

* Verify where to emit the `peer.ringing` Teravoz event and what is the difference between it and the `actor.ringing` event.

* The `actor.logged-in` and the `actor.logged-out` events are emitted for all queues, but in the Teravoz legacy system these events were only emitted when the agent perform a login/logout in a **dialer** queue. For "normal" queues, no events indicating the actor being available/unavailable are emitted. I don't know if it's better to leave the behavior in this way or try to simulate the way that Teravoz works, but then the queues will have to had a property to differentiate the dialer queues from the attendance queues. 

* In order to `data.cpf-provided` and `data-cnpj-provided` to work, they'll also need a function to receive these user inputs and transform it in a custom-event to be converted to the Teravoz event. Thinking on only these two cases, it's OK to build the solution in this way, but if we think about customization and more user inputs that varies by client, it will be a mess to have to create a function to each user input, so maybe it's better to think in a better solution.

# Missing fields

## General

* **code** - This field is intended to be provided by user when triggering the dialer, to recognize an specific call in the events. Maybe it's possible to pass these code if we defines how it will be passed to the TaskRouter's task and how it'll be saved into the task attributes.

## call.new

* **their_number_type** - This info is not provided when the taskRouter callback is triggered on `task.new` event.

## actor.* events

* ~~**queue** - The change of status using the TaskRouter is not related to a queue, so this parameter is not provided by Twilio.~~

>Now, all the actor related events are emitted for each queue that the agent is inserted into. Example: If a agent that belongs to queues 900 and 901 changes his status to available, then two `actor.logged-in` events will be emitted: one for queue `900` and another for queue `901`.

